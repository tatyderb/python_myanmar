# Перебираем элементы

lesson = 1133855

## Перебираем все элементы

В этом уроке:

1. `for` для перебора элементов последовательностей.
2. `map` для получения последовательности.
3. Примеры: найти сумму, максимальный элемент последовательности.
4. `None` - ничего, специальное значение.
5. `next()` - взять следующий элемент последовательности.

### map - получим последовательность

С помощью **for** можно перебрать все элементы последовательности.

Последовательность целых чисел можно получить и перебрать так:

```python
a = map(int, input().split())   # получили последовательность целых чисел

# переберем последовательность по одному элементу и напечатаем числа
for x in a:
    print('Число', x)
```
Ввод:
```python
5 -44 17
```
Вывод:
```python
Число 5
Число -44
Число 17
```
* **Последовательность может быть любой длины**, `for` переберет по одному элементу из нее.
* Очередной элемент записывается в переменную `x` (имя придумали мы сами).

Последовательность:

* получаем с помощью функции **map**
* все элементы имеют одинаковый тип, у нас это `int`
    * если нужно прочитать дробные числа, то пишем `map(float, input().split())`
* по этой последовательности можно пройти один раз, после чтения элемента, он исчезает из последовательности:

```python
a = map(int, input().split())   # получили последовательность целых чисел

# переберем последовательность по одному элементу и напечатаем числа
for x in a:
    print('Число', x)
    
print('--------')

# попробуем перебрать еще раз
for x in a:
    print('Опять число', x)
```
Ввод:
```python
5 -44 17
```
Вывод:
```python
Число 5
Число -44
Число 17
--------
```
Видно, что "Опять число" не было напечатано ни разу. Потому что когда мы проходили в первом цикле, прочитанное число исчезало из последовательности и она стала пустой.

Второй цикл перебирал пустую последовательность.

Это как зубная паста из тюбика. Если мы ее взяли, то вот этого кусочка пасты в тюбике нет. Обратно в последовательность элемент засунуть нельзя. Такие последовательности в питоне называют **генератор**. О них подробно расскажем позже. Сейчас будем использовать **map**.

![зубная паста](https://stepik.org/media/attachments/lesson/1133855/toothpaste_can_put_back_in.jpeg)

## Пример: сумма чисел, сколько чисел?

### Задача про яблоки

В ряду растет несколько яблонь. На каждой яблоне $a_i$ яблок. Сколько яблок на всех яблонях?

Формат входных данных:

* через пробел $a_i$

Пример входных данных:
```cpp
5 2 10
```

Начнем с простого: пусть всегда будет 3 яблони. Просуммируем яблони на 3 деревьях.

Решение "в лоб":
```python
a, b, c = map(int, input().split()) # прочитали сколько яблок
sum = a + b + c                   # всего собрали яблок
print(f'Всего собрали {sum} яблок') 
```

![abc-08.svg](https://stepik.org/media/attachments/lesson/264319/abc-08.svg)

На каждой яблоне установлена памятная табличка с *названием* яблони *эта яблоня была посажена студентом Х после получения зачета по информатике* a, b, c.

Решение верное, но абсолютно не масштабируется. Если в ряду станет 7 яблонь, то нужно вспоминать алфавит, и писать много неповторяющегося кода. Если яблонь будет 100, букв не хватит.

Попробуем переписать код так, чтобы с ростом яблонь количество переменных не изменялось. А код обработки одной яблони можно было бы копировать.


### Яблони в ряду, пишем таблицу

Введем переменные:

* `i` - номер яблони, начинаем с 0 (или "сколько яблонь уже обработали")
* `x` - яблок на одной (текущей) яблоне;
* `sum` - яблок уже собрали (в корзине, куда собираем яблоки).

![Рисунок i_and_x-09.svg](https://stepik.org/media/attachments/lesson/264319/i_and_x-09.svg)

Нарисуем таблицу, в которой стрелками покажем как изменяются переменные:

<p style="text-align:center"><img alt="Таблица изменения переменных" src="https://stepik.org/media/attachments/lesson/264319/table_sum.svg" /></p>

Получим формулы:

* `i += 1`
* очередной элемент последовательности лежит в `x`
* `sum += x`

В каком порядке писать формулы? 

* изменение `i` не зависит от изменения `x` или `sum`, то есть `i += 1` можно писать в любом месте.
* `sum += x` зависит от `x`, поэтому мы пишем эту формулу *после* записи очередного числа в `x`.

```python
seq = map(int, input().split())   # получили последовательность целых чисел

for x in seq:
    sum += x    # добавили яблоки с яблони в корзину
    i += 1      # прошли еще одно дерево
```
Такой код работать не будет. Питон не знает, к чему прибавлять в выражениях `sum += x` и `i += 1`. 

![Рисунок LocalVariableInitializing-Version3-05.svg](https://stepik.org/media/attachments/lesson/264319/LocalVariableInitializing-Version3-05.svg)

Надо проинициализировать переменные. Сначала корзина пустая. Ни одной яблони еще не прошли.

```python
seq = map(int, input().split())   # получили последовательность целых чисел

# инициализируем переменные
sum = 0         # сначала корзина пустая
i = 0           # ни одного дерева не прошли

for x in seq:
    sum += x    # добавили яблоки с яблони в корзину
    i += 1      # прошли еще одно дерево
    print(f'i={i} x={x} sum={sum}')
    
print(f'Всего собрали {sum} яблок, в саду {i} дерева') 
```
Входные данные:
```python
5 2 10
```
Выходные данные:
```python
i=1 x=5 sum=5
i=2 x=2 sum=7
i=3 x=10 sum=17
Всего собрали 17 яблок, в саду 3 дерева
```

## QUIZ i += 1

Что будет делать программа, если не написали `i += 1`?

```python
seq = map(int, input().split())   # получили последовательность целых чисел

# инициализируем переменные
sum = 0         # сначала корзина пустая
i = 0           # ни одного дерева не прошли

for x in seq:
    sum += x    # добавили яблоки с яблони в корзину
    print(f'i={i} x={x} sum={sum}')
    
print(f'Всего собрали {sum} яблок, в саду {i} дерева') 
```

A. Напечатает `Всего собрали 17 яблок, в саду 3 дерева`

B. Будет бесконечный цикл, сумма будет все время расти.

C. Напечатает `Всего собрали 0 яблок, в саду 0 дерева`, так как цикл не выполнится ни разу. 

D. Напечатает `Всего собрали 17 яблок, в саду 0 дерева`

ANSWER: D

## TASKINLINE сумма четных чисел

**Прочитайте** числа. Напечатайте сумму **четных** чисел.

10 + -6 + 8 = 12

TEST
10 -3 -6 8
----
12
====
3 4
----
4
====
10
----
10
====
1 2 3 4 5 6 7 8 9
----
20
====
-1 -2 -3 -4 -5 -6 -7 -8 -9
----
-20
====


## TASKINLINE Произведение чисел

Даны целые числа через пробел на одной строке. Найдите их произведение.

TEST
2 5 -3
----
-30
====
1 0 4 5 9 11 123
----
0
====
1 2 3 4 5
----
120
====
-7
----
-7
====

## TASKINLINE Сумма обратных чисел

Даны целые числа (без 0) через пробел на одной строке $a_0, a_1, .. a_n$. Найдите сумму чисел

$$ \frac{1}{a_0} +  \frac{1}{a_1} + .. + \frac{1}{a_n}$$

Напечатайте найденную сумму с точностью до 3 знаков. Для печати переменной `х` с точностью до 3 знаков, используйте `print(f'{x:.3f}')`

TEST
1 2 4
----
1.750
====
1 -2 4
----
0.750
====
8
----
0.125
====
1 2 3 4 5 6 7 8 9 10
----
2.929
====

## TASKINLINE максимум и минимум

Дан рост студентов в сантиметрах. Какой рост самого высокого студента?

Будем по одному измерять студентов и записывать рекорд роста в переменную `hmax`. 

* Прочитаем все числа.
* Проинициализируем `hmax` (каким значением?)
* В цикле 
    * будем брать по одному числу и записывать в переменную `height` (рост)
    * если рост нового студента больше, чем `hmax`
        * запомним в `hmax` этот новый рекорд роста.
* Напечатаем `hmax` - рекорд после того, как измерили всех студентов.

Рост студентов точно будет больше 0. Поэтому можно до цикла написать `hmax = 0`. Когда будем сравнивать рост *первого(* студента с 0, рост студента будет больше и мы запомним рост первого студента как рекорд в `hmax`:

```python
a = map(int, input().split())   # прочитали все числа в последовательность
hmax = 0                        # пока рекордный рост 0 см.

for h in a:                     # рост очередного студента хранится в h
    if h > hmax:                # если его рост больше рекорда
        hmax = h                # запишем его рост, как рекорд
    print(f'{h=}\t{hmax=}')     # отладочная печать, печатаем рост студента и рекорд

print(f'Рост самого высокого студента {hmax} см')
``` 
Входные данные:
```cpp
155 160 152 169 189 157 180 172
```
Выходные данные:
```cpp
h=155   hmax=155
h=160   hmax=160
h=152   hmax=160
h=169   hmax=169
h=189   hmax=189
h=157   hmax=189
h=180   hmax=189
h=172   hmax=189
Рост самого высокого студента 189 см
```

Формат `{h=}` работает в питон 3.10 и выше. На момент написания курса на степике используется питон 3.6. Если у вас не работает программа, замените отладочную печать на `print(f'h={h}\thmax={hmax}')`

**Измените программу**, чтобы найти рост самого **низкого** студента

CODE
a = map(int, input().split())
hmax = 0

for h in a:
    if h > hmax:
        hmax = h
    print(f'h={h}\thmax={hmax}')

print(f'Рост самого высокого студента {hmax} см')

TEST
155 160 152 169 189 157 180 172
----
152
====
150 160 152 169 189 157 180 172
----
150
====
155 160 152 169 189 157 180 172 151
----
151
====
165 161 190 182 169 189 167 180 172
----
161
====
165 190 182 169 189 167 180 162 172
----
162
====
155
----
155
====

## Температура

Даны числа - температура в градусах Цельсия. Найти самую низкую температуру.

Какое число записать рекордом температуры ДО цикла? 0? 100? Температуру Солнца?

### None - не число

Можно записать до цикла в рекорд "не число", особую константу **None**. Нельзя сравнивать `x < None` или `x >= None`.

Можно сравнить `x == None`. Но правильно написать:

* **x is None** - проверка, что `х` это `None`
* **x is not None** - проверка, что `х` это не `None`

Запишем рекорд до цикла `None` и в цикле запишем проверку: если рекорд еще не установлен (`t is None`), то это первое число и запишем его в рекорд:

```python
a = map(int, input().split())   # прочитали все числа в последовательность
tmin = None                     # рекорда температуры еще никакого нет

for t in a:                     # очередная температура хранится в t
    if tmin is None:            # если рекорда еще нет
        tmin = t                # то это число будет рекордом
        print('Установлен первый рекорд {tmin}')
    if t < tmin:                # если температура ниже рекорда
        tmin = t                # запишем эту температуру как рекорд
    print(f'{t=}\t{tmin=}')     # отладочная печать, печатаем текущую температуру и рекорд

print(f'Самая низкая температура {tmin} C')
```
Входные данные:
```python
15 22 10 -5
```
Выходные данные:
```python
Установлен первый рекорд 15
t=15    tmin=15
t=22    tmin=15
t=10    tmin=10
t=-5    tmin=-5
Самая низкая температура -5 С
```

### next(a)

Хочется сразу взять первое число как рекорд. А в цикле перебирать другие числа.

**next**(последовательность) - извлекает элемент из последовательности и возвращает его. 

*Все, вода из шланга вытекла, зубная паста выдавлена, элемента в последовательности больше нет!*

Введем числа `5 2 10`, когда будем читать последовательность чисел.

Извлечем очередное число с помощью `next` в консоли питона:
```python
>>> a = map(int, input().split())
5 2 10
>>> next(a)
5
>>> next(a)
2
>>> next(a)
10
>>> next(a)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```
Видим, что введены числа 5 2 10, а извлекает их `next()` по одному, пока может. Когда извлекать нечего, возникает ошибка.

Мы до ошибки доводить не будем, до цикла возьмем первую температуру как рекорд с помощью next.

```python
a = map(int, input().split())   # прочитали все числа в последовательность
tmin = next(a)                  # первую температуру сначала считаем рекордом

                                # в a первой температуры уже нет!
for t in a:                     # очередная температура хранится в t
    if t < tmin:                # если температура ниже рекорда
        tmin = t                # запишем эту температуру как рекорд
    print(f'{t=}\t{tmin=}')     # отладочная печать, печатаем текущую температуру и рекорд

print(f'Самая низкая температура {tmin} C')
```

Входные данные:
```python
15 22 10 -5
```
Выходные данные:
```python
t=22    tmin=15
t=10    tmin=10
t=-5    tmin=-5
Самая низкая температура -5 С
```
Как видите, цикл начался со второй температуры 20.

## QUIZ Сравнение с None

Отметьте конструкции, которые равны `True` или `False`, если `x = 5`

A. `x is None`
B. `x == None`
C. `x < None`
D. `x > None`
D. `x >= None`

ANSWER: A, B

## QUIZ elif

Дана программа.
```python
a = map(int, input().split())   # прочитали все числа в последовательность
tmin = None                     # рекорда температуры еще никакого нет

for t in a:                     # очередная температура хранится в t
    if tmin is None:
        tmin = t
        print('Установлен первый рекорд {tmin}')
    elif t < tmin:
        tmin = t
        
print(tmin)
```

Выберите, какое число будет напечатано, если введут
```python
-15 22 10 -5
```
A. -15
B. 22
C. 10
D. -5
E. None
F. Будет ошибка сравнения c None

SHUFFLE: false
ANSWER: A

## QUIZ порядок сравнения

Дана программа.
```python
a = map(int, input().split())   # прочитали все числа в последовательность
tmin = None                     # рекорда температуры еще никакого нет

for t in a:                     # очередная температура хранится в t
    if t < tmin:
        tmin = t
    if tmin is None:
        tmin = t
        # print('Установлен первый рекорд {tmin}')
        
print(tmin)
```

Выберите, какое число будет напечатано, если введут
```python
-15 22 10 -5
```
A. -15
B. 22
C. 10
D. -5
E. None
F. Будет ошибка сравнения c None

SHUFFLE: false
ANSWER: F

## QUIZ

Дана программа:
```python
a = map(int, input().split())

x = next(a)
y = next(a)

print(x, y)
```
Что будет напечатано, если ввели
```python
7 11 -8 132
```

A. 7 11
B. 7 7
C. 11 11
D. Произойдет ошибка
E. Другое

SHUFFLE: false
ANSWER: A

## TASKINLINE

Даны целые числа. Найти наименьшее **по модулю** число.

TEST
-10 5 7 123 -2 1 45
----
1
====
8 99 102 6
----
6
====
-3 -45 -111 -5
----
-3
====
9
----
9
====
1 2 3 0 4 5
----
0
====

## TASKINLINE Сумма максимального и минимального числа

Даны числа. Найти сумму максимального и минимального числа. Ответ напечатать с точностью до 2 знаков.

TEST
5.8 3.2 -12.4 98.345 100.634
----
88.23
====
-1.2345 0.98 8.5
----
7.27
====
7.123 7.34 7.1 7.984
----
15.08
====
-7.123 -7.34 -7.1 -7.984
----
-15.08
====
2.34
----
4.68
====

## Уже есть в python встроенные функции

* **sum**(последовательность) - возвращает сумму всех элементов последовательности;
* **min**(последовательность) - возвращает минимальный элемент последовательности;
* **max**(последовательность) - возвращает максимальный элемент последовательности;

Найти сумму чисел последовательности можно было решить так:
```python
a = map(int, input().split())
res = sum(a)
print(res)
```

Минимальное число:
```python
a = map(int, input().split())
res = min(a)
print(res)
```

### Параметр key

У функций `sum`, `min`, `max` есть параметр **key**. В него передается какая функция будет применяться к каждому элементу последовательности, прежде чем будет вычисляться сумма (искаться минимум и максимум).

Найти наименьшее по модулю число. Параметру `key` передали функцию взятия модуля `abs`:
```python
a = map(int, input().split())
res = min(a, key=abs)
print(res)
``` 
Функцию можно написать самим. Сумму $ \frac{1}{a_0} +  \frac{1}{a_1} + .. + \frac{1}{a_n}$ найдем с помощью функции `sum`. Ей передадим нашу функцию `drob(x)`, которая возвращает `1/x`

```python
def drob(x):
    return 1/x
    
a = map(int, input().split())
res = sum(a, key=drob)
print(res)
``` 

### Два раза

Мы пока не можем решить задачу найти сумму минимального и максимального числа последовательности как

```python
a = map(int, input().split())   # прочитали все числа в последовательность
res = min(a) + max(a)
print(res)
```
Потому что `min(a)` возьмет **все числа** из последовательности `a` и `max(a)` будет перебирать **пустую последовательность**.

```python
>>> a = map(int, input().split())
5 2 10
>>> x1 = max(a)
>>> x1
10
>>> x2 = min(a)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: min() arg is an empty sequence
>>>
```