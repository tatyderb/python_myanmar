# Sort+key

lesson = 496941

## key=функция - как сравнивать объекты

* **список.sort(key=None, reverse=False)** - стабильная сортировка самого списка
* **sorted(iterable, key=None, reverse=False)** - из iterable создается новый отсортированный список, старый остается без изменения.

Параметр **key=функция** - как сравнивать объекты.

Функция **abs(x)** возвращает $|x|$. Это встроенная функция, как `len()`. Для нее не нужно `import`.

Отсортируем числа по возрастанию *модуля* числа:

```python
a = [3, 6, -8, 2, -78, 1, 23, -45, 9]

b = sorted(a, key=abs)
print(a)       # [3, 6, -8, 2, -78, 1, 23, -45, 9]
print(b)       # [1, 2, 3, 6, -8, 9, 23, -45, -78]

a.sort(key=abs)
print(a)       # [1, 2, 3, 6, -8, 9, 23, -45, -78]
```

## Отсортируем строки по длине

Отсортируем строки по длине. Длину строки вычисляет функция **len(s)**.

```python
text = ['ccc', 'aaaa', 'd', 'bb']   # ['ccc', 'aaaa', 'd', 'bb']
print sorted(text, key=len)         # ['d', 'bb', 'ccc', 'aaaa']
```
Как это работает?

Функция должна принимать 1 аргумент (value) и возвращать 1 значение (proxy value).

Как сортируем с ключевой функцией:

* по списку value вычисляем список proxy value
* сортируем список proxy value
* по отсортированным proxy value ставим на место value.

![](https://stepik.org/media/attachments/lesson/496941/sorted-key.png)

## Сортировка по proxy value в реальной жизни

Мы так же сортируем в реальной жизни. Пусть у нас есть грузовые контейнеры. Их нужно отсортировать по весу. Тяжелые погрузить на корабль ниже, легкие выше. Иначе корабль будет неустойчивый.

![](https://upload.wikimedia.org/wikipedia/commons/0/05/M%C3%A6rsk_Triple_E.jpg)

На контейнеры есть документы. В каждом документе указан вес. Проще сначала отсортировать документы по весу контейнера, а потом по документу брать нужный контейнер и грузить на корабль.

## Сортировка строк без учета регистра

Отсортируем список строк БЕЗ учета регистра. Для этого будем сортировать строки, которые приведены к нижнему регистру.

Приводит к нижнему регистру метод **lower** класса **str**. Пишем полное имя функции **str.lower**.

```python
strs = ['aa', 'BB', 'zz', 'CC']
print(sorted(strs))                  # ['BB', 'CC', 'aa', 'zz'] (case sensitive)
print(sorted(strs, key=str.lower))   # ['aa', 'BB', 'CC', 'zz']
```

## Сортировка разнотипных объектов

Сравнивать данные разных типов нельзя. Получим ошибку.
```
>>> 3 < "5"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '<' not supported between instances of 'int' and 'str'
```
Значит, сортировать их тоже нельзя.

Есть
```python
a = ["1.3", 7.5, "5", 4, "2.4", 1]
```
Что делать? Сделаем их одинаковым типом `float`.
```python
a = [float("1.3"), float(7.5), float("5"), float(4), float("2.4"), float(1)]
```
можно это сделать при сортировке:
```python
sorted(["1.3", 7.5, "5", 4, "2.4", 1], key=float)
```

## Напишем свою функцию сравнения

Есть список строк. Нужно отсортировать строки по **последней букве**.

Функции "взять последнюю букву" нет. Надо написать ее самим. key function должна брать 1 строку и возвращать 1 значение, по которому будем сортировать. У нас функция должна вернуть последнюю букву.

```python
strs = ['xc', 'zb', 'yd' ,'wa']

# возвращает последний символ строки
def last_letter(s):
    return s[-1]

# сортирует список строк только по последним буквам
b = sorted(strs, key=last_letter)  ## ['wa', 'zb', 'xc', 'yd']
```

## Сортируем по росту и весу

Даны рост (см) и вес (кг) каждого человека. Отсортируем людей.

```python
a = [(166, 55.2), (157, 55.2), (170, 55.2), (175, 90), (166, 73), (180, 73)]
print(a)

b = sorted(a)
print(b)    # [(157, 55.2), (166, 55.2), (166, 73), (170, 55.2), (175, 90), (180, 73)]
```
Вспомним, как сравниваются составные объекты. Сначала первые элементы, потом вторые и дальше. У нас сначала рост. Если рост одинаковый, то сравниваем вес.

Хотим сравнить только по весу. Как? Напишем функцию, которая будет брать 1 человека и возвращать 1 число вес человека. Отсортируем список с этой функцией.

```python
def weight(t):
    h = t[0]
    w = t[1]
    return w  # или return t[1]

b = sorted(a, key=weight)
print(b)
# [(166, 55.2), (157, 55.2), (170, 55.2), (166, 73), (180, 73), (175, 90)]
```

Сортировка **стабильная** (stable). То есть если в списке а при **одинаковом весе** 55.2 был сначала человек (166, 55.2), потом (157, 55.2), потом (170, 55.2). То в отсортированном массиве их **взаимный порядок не изменится**.

Заметим, что люди с одинаковым весом идут в том же порядке, что и в списке до сортировки: при весе 55.2 сначала 166, потом 157. При весе 73 сначала 166, потом 180.

Сортировка в питоне стабильная, то есть равные по одному признаку элементы будут идти в том же порядке, что и до сортировки.

## Сортировка по убыванию веса

Отсортируем по весу по убыванию. Не будем использовать `reverse = True`, сделаем это через функцию.

```python
def weight_decr(t):
    h = t[0]
    w = t[1]
    return -w  # или return -t[1]

b = sorted(a, key=weight_decr)
print(b)
# [(175, 90), (166, 73), (180, 73), (166, 55.2), (157, 55.2), (170, 55.2)]
```

## Сложный критерий

Отсортируем по весу (по возрастанию), а при равном весе - по росту (по возрастанию).

Для этого в функции, которая возвращает proxy values вернём 1 tuple, в котором все критерии сортировки (вес, рост).

```python
def wh1(t):
    h = t[0]
    w = t[1]
    return (w, h)  # обязательно возвратить tuple, главное вес, потом рост

b = sorted(a, key=wh1)
print(b)
# [(157, 55.2), (166, 55.2), (170, 55.2), (166, 73), (180, 73), (175, 90)]
```

## По возрастанию и убыванию

Как отсортировать **по возрастанию** веса и при равном весе **по убыванию** роста?

```python
def wh2(t):
    h = t[0]
    w = t[1]
    return (w, -h)  # обязательно возвратить tuple

b = sorted(a, key=wh2)
print(b)
# [(170, 55.2), (166, 55.2), (157, 55.2), (180, 73), (166, 73), (175, 90)]
```

## Читаем рост и вес для многих людей

Файл `data.txt`
```cpp
166 55.2
157 55.2
170 55.2
175 90
166 73
180 73
```

Читаем эти данные в список `peoples`:

```python
import sys
fin = sys.stdin

a = []
for line in fin:
    if not line.rstrip():
        continue
    w, h = line.split()
    w = int(w)
    h = float(h)
    a.append((w, h))    # добавляем в список a кортеж (w, h)

print(a)    # [(166, 55.2), (157, 55.2), (170, 55.2), (175, 90.0), (166, 73.0), (180, 73.0)]
```