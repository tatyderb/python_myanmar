# Методы словарей

lesson = 527241

## Цикл со словарем

Цикл можно перебирать

Оценки студентов за контрольную:
```python
grades = {
    'Bob': 7,
    'Alex': 5,
    'David': 8,
    'Charly': 2
}
```
Переберем по 1 студенту и напечатаем их красиво
```python
for name in grades:
	print(name, grades[name])
```
получим
```python
Bob 7
Alex 5
David 8
Charly 2
```

## Методы словаря для перебора

* **keys()** - список ключей
* **values()** - список значений
* **items()** - список пар (ключ, значение)

### Перебор по ключам

**keys()** - cловарь перебираем по ключам:
```python
for student in grades.keys():
    print(student, grades[student])
```
То же самое:
```python
for student in grades:          # словарь перебираем по ключам
    print(student, grades[student])
```

Зачем нужно **keys()**, если работает перебор по словарю? Можно отсортировать ключи и напечатать по алфавиту:

```python
for student in sorted(grades.keys()):
    print(student, grades[student])
```

## Перебор по значениям

**values()** - список значений.

```python
for v in grades.values():   # словарь перебираем по значениям
    print(v)
```
Помните, значения могут совпадать. Разные студенты (ключ) могут получить оценку 8 (значение).

Порядок в `keys()` и `values()` совпадает. То есть
```python
dict(zip(d.keys(), d.values()))  # совпадает с d
```
Получим такой же словарь `d`.

## Перебор по парам

**items()** - список пар (ключ, значение)

```python
for student, score in grades.items():
    print(student, score)
```
То же самое, но работает медленнее:
```python
for student in grades:          
    print(student, grades[student])
```

## Методы keys(), values(), items()

Словарь:
```python
>>> print(grades)
{'Hein': 10, 'Arkar': 8, 'Sai': 9, 'Thaw': 7, 'Lin': 8}
>>> print(type(grades))
<class 'dict'>
```
Ключи:
```python
>>> print(grades.keys())
dict_keys(['Hein', 'Arkar', 'Sai', 'Thaw', 'Lin'])
>>> print(type(grades.keys()))
<class 'dict_keys'>
```
Значения:
```python
>>> print(grades.values())
dict_values([10, 8, 9, 7, 8])
>>> print(type(grades.values()))
<class 'dict_values'>
```
Пары (ключ, значение):
```python
>>> print(grades.items())
dict_items([('Hein', 10), ('Arkar', 8), ('Sai', 9), ('Thaw', 7), ('Lin', 8)])
>>> print(type(grades.items()))
<class 'dict_items'>
```

## Свойства ключей и значений

* **ключ** - должен быть **уникальным** и **неизменяемым** (на самом деле хешируемым, но об этом термине узнаем позже).
* **значение** - может быть любое

* Неизменяемые (unmutable) типы: строки `'Moscow'`, числа `12`, кортеж `(1, 3, 17)` и другие.
* Изменяемые типы (mutable) типы: списки `[1, 3, 17]`

## TASKINLINE Счетчик чисел

Даны числа. Напечатать число и сколько раз оно встретилось. 

Для решения использовать словарь `d[number] = count`, где 

* `number` - число
* `count` - сколько раз оно встретилось

TEST
1 4 6 2 3 6 3 0 2 4 2 2 4
----
1 1
4 3
6 2
2 4
3 2
0 1
====
1 1 1 1 1
----
1 5
====
-3 124 82 90123
----
-3 1
124 1
82 1
90123 1
====

## TASKINLINE Без повторов

Даны числа. Напечатать числа. Убрать повторения.

TEST
1 4 6 2 3 6 3 0 2 2 2 4
----
1 4 6 2 3 0
====
1 1 1 1 1
----
1
====
-3 124 82 90123
----
-3 124 82 90123
====

## TASKINLINE Уникальные

Даны числа. Напечатать только уникальные числа у которых не было повторений.

TEST
1 4 6 2 3 6 3 0 2 2 2 4
----
1 0
====
1 1 1 1 1 11
----
11
====
-3 124 82 90123
----
-3 124 82 90123
====

## TASKINLINE Без повторов

Даны числа. Каждое число печатать только 1 раз. Напечатать числа в том порядке, в котором они встретились в первый раз.

Возможно, вы уже решили эту задачу.

TEST
1 4 6 2 3 6 3 0 2 2 2 4
----
1 4 6 2 3 0
====
1 1 1 1 1
----
1
====
-3 124 82 90123
----
-3 124 82 90123
====





