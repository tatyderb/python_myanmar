# class Segment1

lesson = 532648

## Класс Segment1 - отрезок на оси Х

Опишем класс - отрезок на оси Х.

* У каждого отрезка есть начало (start) и конец (finish) - это его атрибуты (переменные).
* Что можно сделать с отрезком? Его можно 
    * напечатать, 
    * вычислить длину, 
    * сдвинуть по оси Х вправо или влево.

Создадим новый тип и назовем его `Segment1`.

## Определение функции (повторение)

Напишем функцию **dist(x1, y1, x2, y2)**. Она считает расстояние между точками (x1, y1) и (x2, y2).

```python
def dist(x1, y1, x2, y2):
    a = x1 - x2
    b = y1 - y2
    res = sqrt(a*a + b*b)
    return res
```

* **Определение функции**
    * **def** ключевое слово
    * имя функции
    * список аргументов в `()`
    * `:` в конце
```python
def dist(x1, y1, x2, y2):
```

Тело функции - все, что внутри функции (написано с отступом TAB)
```python
    # это тело функции dist:
    a = x1 - x2
    b = y1 - y2
    res = sqrt(a*a + b*b)
    return res
```

**Вызов функции**
```python
d = dist(1, 3, -5, 6)   # вычисляем расстояние между точками (1,3) и (-5,5)
```

## Определение класса и создание объектов класса

* **класс** - это **описание** что может хранится в объекте и что можно с объектом делать.

Опишем класс Segment1. Он определяет отрезок на оси Х. Пока можно только создать отрезок.

```python
# определение класса Segment1
class Segment1:
    """Класс Segment1 описывает отрезки на оси Х"""
    
    def __init__(self, start=0, finish=0):
        # Эта функция вызывается, когда мы создаем новый объект класса.
        # self - это название переменной, которая указвает на сам объект.
        self.start = start      # переменная объекта 
        self.finish = finish
        
# закончились отступы - закончился класс
# дальше можно класс использовать

# Создадим два отрезка [-150, 50] и [100, 230]
s1 = Segment1(-150, 50)     # создали объект класса Segment1, на него ссылается переменная s1 - первый отрезок
s2 = Segment1(100, 230)     # создали объект класса Segment1, на него ссылается переменная s2 - второй отрезок

s1.start = -120             # первый отрезок теперь [-120, 50]

print(s1.start, s1.finish)  # -120 50
print(s2.start, s2.finish)  # 100 230
```

* **Определение класса**:
    * **class** - специальное слово
    * имя класса. Принято писать с большой буквы
    * `:` в конце
```python
class Segment1:
```

**Тело класса** пишем с отступом TAB.

Принято в начале писать в `"""` что делает класс. Удобнее читать короткий текст, чем весь код класса.
```python
    """Класс Segment1 описывает отрезки на оси Х"""
```

**Имя класса принято писать с большой буквы**

## Создаем объект класса. Конструктор

Для описания отрезка [-150, 50] создадим объект класса Segment1, на него ссылается переменная s1.
```python
s1 = Segment1(-150, 50)
```
**Имя функции должно совпадать с именем класса**.

Что происходит при вызове `Segment1(-150, 50)`?

* Выделяется память для объекта
* в эту память записываются данные. Говорят, что объект инициализуется (initialize). Для этого используют специальный метод класса. Он называется **конструктор**. У него специальное имя `__init__`
* аргументы передаются в этот конструктор.

Конструктор:
```python
    def __init__(self, start=0, finish=0):
        # Эта функция вызывается, когда мы создаем новый объект класса.
        # self - это название переменной, которая указвает на сам объект.
        self.start = start      # переменная объекта 
        self.finish = finish
```

**self**  - первый аргумент **всех** методов объекта. Это **ссылка на сам объект**.

У объекта есть переменные `start` и `finish`. К ним можно обратиться 

* **изнутри объекта** - из любой функции объекта класса Segment1
    * **self**.`start`
* по ссылке
    * `s1.start`, где `s1` - имя переменной.

```python
s1.start = -120             # первый отрезок теперь [-120, 50]
```    
    
Вся программа:
```python
# определение класса Segment1
class Segment1:
    """Класс Segment1 описывает отрезки на оси Х"""
    
    def __init__(self, start=0, finish=0):
        # Эта функция вызывается, когда мы создаем новый объект класса.
        # self - это название переменной, которая указвает на сам объект.
        self.start = start      # переменная объекта 
        self.finish = finish
        
# закончились отступы - закончился класс
# дальше можно класс использовать

# Создадим два отрезка [-150, 50] и [100, 230]
s1 = Segment1(-150, 50)     # создали объект класса Segment1, на него ссылается переменная s1 - первый отрезок
s2 = Segment1(100, 230)     # создали объект класса Segment1, на него ссылается переменная s2 - второй отрезок

s1.start = -120             # первый отрезок теперь [-120, 50]

print(s1.start, s1.finish)  # -120 50
print(s2.start, s2.finish)  # 100 230
```

## self.start и start

Сколько переменных с именем `start` в конструкторе?
```python
    def __init__(self, start=0, finish=0):
        # Эта функция вызывается, когда мы создаем новый объект класса.
        # self - это название переменной, которая указвает на сам объект.
        self.start = start      # переменная объекта 
        self.finish = finish
```

Две. 

* `self.start` - переменная объекта или **атрибут** объекта.
* `start` - аргумент функции. Это другая переменная.

Поэтому можно писать
```python
self.start = start
```

## TASKINLINE class Point

![length2D.png](https://stepik.org/media/attachments/lesson/532648/length2D.png)

* Определите класс `Point`. Он описывает точку на плоскости.
* Напишите в нем конструктор. Задайте атрибуты `x` и `y`
* Создайте 2 объекта. Координаты задайте как у двух точек на рисунке.
* Прочитайте координаты еще одной точки. Создайте объект класса Point
* Напечатайте координаты левой точки
* Напечатайте координаты правой точки
* Напечатайте координаты прочитанной точки

TEST
1 4
----
-5 2
6 -5
1 4
====

## Метод в класс Segment1. Возвращает число

Вычислим длину отрезка. Для этого нужны только координаты концов отрезка.

Напишем метод (функцию объекта класса) `length`. Первый аргумент **self**. Других не нужно. Координаты хранятся в `self.start` и `self.finish`

```python
# определение класса Segment1
class Segment1:
    """Класс Segment1 описывает отрезки на оси Х"""
    
    def __init__(self, start=0, finish=0):
        # Эта функция вызывается, когда мы создаем новый объект класса.
        # self - это название переменной, которая указвает на сам объект.
        self.start = start      # переменная объекта 
        self.finish = finish
        
    def length(self):
        """Возвращает длину отрезка"""
        return abs(self.start - self.finish)
        
# закончились отступы - закончился класс
# дальше можно класс использовать

# Создадим два отрезка [-150, 50] и [100, 230]
s1 = Segment1(-150, 50)     # создали объект класса Segment1, на него ссылается переменная s1 - первый отрезок
s2 = Segment1(100, 230)     # создали объект класса Segment1, на него ссылается переменная s2 - второй отрезок

s1.start = -120             # первый отрезок теперь [-120, 50]

print(s1.start, s1.finish)  # -120 50
print(s2.start, s2.finish)  # 100 230

# добавим проверку метода length()
len1 = s1.length()
print(s1.start, s1.finish, len1)  # -120 50 170
len2 = s2.length()
print(s2.start, s2.finish, len2)  # 100 230 130
```

Обратите внимание! Первый аргумент **self**

* При объявлении метода первый аргумент должен быть `self`.
    * `def length(self):`
* при вызове функции пишем **ссылка.метод**. Мы так писали у строк и черепахи.
    * внутри класса `self.length()`
    * вне класса `s1.length()`
    
## Печатаем объект красиво

Попробуем напечатать отрезок:
```python
print(s1)
```    
получим что-то подобное:
```cpp
<__main__.Segment1 object at 0x00000212FE5BFD60>
```
Хочется, чтобы печатал начало, конец и длину отрезка.

Для этого нужно 

* написать метод со специальным названием `__repr__`
* у него обязательно первый аргумент `self`
* метод возвращает строку

```python
    def __repr__(self):
        mylen = self.length()
        return f'[{self.start}, {self.finish}]:{mylen}'
```
После этого 
```python
print(s2)   # [100, 230]:240
```
Когда мы печатаем объект, то автоматически вызывается метод `s2.__repr__`()`, из объекта получаем строку.

Вся программа:
```python
# определение класса Segment1
class Segment1:
    """Класс Segment1 описывает отрезки на оси Х"""
    
    def __init__(self, start=0, finish=0):
        # Эта функция вызывается, когда мы создаем новый объект класса.
        # self - это название переменной, которая указвает на сам объект.
        self.start = start      # переменная объекта 
        self.finish = finish

    def __repr__(self):
        mylen = self.length()
        return f'[{self.start}, {self.finish}]:{mylen}'     # не забудьте f перед строкой
        
    def length(self):
        """Возвращает длину отрезка"""
        return abs(self.start - self.finish)
        
# закончились отступы - закончился класс
# дальше можно класс использовать

# Создадим два отрезка [-150, 50] и [100, 230]
s1 = Segment1(-150, 50)     # создали объект класса Segment1, на него ссылается переменная s1 - первый отрезок
s2 = Segment1(100, 230)     # создали объект класса Segment1, на него ссылается переменная s2 - второй отрезок

s1.start = -120             # первый отрезок теперь [-120, 50]

print(s1.start, s1.finish)  # -120 50
print(s2.start, s2.finish)  # 100 230

# добавим проверку метода length()
len1 = s1.length()
print(s1.start, s1.finish, len1)  # -120 50 170
len2 = s2.length()
print(s2.start, s2.finish, len2)  # 100 230 130

print(s1)   # [-120, 50]:170
print(s2)   # [100, 230]:240
```

## Тестирование

Каждый раз, когда нужно написать новый метод, нужно **сначала** написать, как будем его проверять. Так проще писать новые методы.

Для этого пишут тесты (проверки). 

Мы уже написали много проверок. В них сложно разобраться. Тесты должны быть простые, короткие и понятные.

Хорошо, если один тест не зависит от другого. Это называется **атомарность** теста.

Для проверки будем писать функции. Чтобы понять, что это тесты, будем называть их `test_чтопроверяет`.

У нас проверяли что можно:

* создать объект класса
* у него есть поля `start` и `finish`
* их можно менять
* есть метод `length`,  он вычисляет длину отрезка
* есть метод печати отрезка и его длины

```python
# напишем функцию проверки:
def test_create():
    # Создадим два отрезка [-150, 50] и [100, 230]
    s1 = Segment1(-150, 50)     # создали объект класса Segment1, на него ссылается переменная s1 - первый отрезок
    s2 = Segment1(100, 230)     # создали объект класса Segment1, на него ссылается переменная s2 - второй отрезок

    s1.start = -120             # первый отрезок теперь [-120, 50]

    print(s1.start, s1.finish)  # -120 50
    print(s2.start, s2.finish)  # 100 230

    # добавим проверку метода length()
    len1 = s1.length()
    print(s1.start, s1.finish, len1)  # -120 50 170
    len2 = s2.length()
    print(s2.start, s2.finish, len2)  # 100 230 130

    print(s1)   # [-120, 50]:170
    print(s2)   # [100, 230]:240

# вызовем функцию проверки
test_create()
```

## assert

`print` помогает быстро найти в чем ошибка. Он показывает данные.

Но очень много печатает. Я могу пропустить, где ошибка.

Python сам может проверять правильное значение или нет.

**assert выражение**

* Если выражение True, то ничего не происходит. 
* Если выражение False, то печатается AssertionError и программа останавливается

```python
>>> x = 5
>>> x
5
>>> assert x < 10
>>> assert x > 10
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    assert x > 10
AssertionError
```
Можно написать **assert выражение, сообщение**. Тогда после `AssertionError` будет печататься _сообщение_:
```python
>>> assert x > 10, "х должно равняться 5"
Traceback (most recent call last):
  File "<pyshell#4>", line 1, in <module>
    assert x > 10, "х должно равняться 5"
AssertionError: х должно равняться 5
```
Всегда печатается **имя файла** и **номер строки в файле**.

Перепишем тест с использованием `assert` и разделим на маленькие тесты.

## Тесты с assert

```python
# напишем функцию проверки:
def test_create():
    """Тест проверяет создание отрезков и их атрибуты"""
    
    # Создадим два отрезка [-150, 50] и [100, 230]
    s1 = Segment1(-150, 50)     # создали объект класса Segment1, на него ссылается переменная s1 - первый отрезок
    s2 = Segment1(100, 230)     # создали объект класса Segment1, на него ссылается переменная s2 - второй отрезок

    print(s1.start, s1.finish)  # -150 50
    assert s1.start == -150
    assert s1.finish == 50
    print(s2.start, s2.finish)  # 100 230
    assert s2.start == 100
    assert s2.finish == 230

    s1.start = -120             # первый отрезок теперь [-120, -30]
    s1.finish = -30

    print(s1.start, s1.finish)  # -120 -30
    assert s1.start == -120
    assert s1.finish == -30

def test_length():
    """Тест проверяет функцию length"""
    
    # Создадим отрезок
    s1 = Segment1(-100, 20)

    # добавим проверку метода length()
    len1 = s1.length()
    # печать должна показывать всю информацию, если длина считается неправильно
    print(s1.start, s1.finish, len1)  # -100 20 120
    assert len1 == 120


def test_str():
    # Создадим два отрезка [-120, 50] и [100, 230]
    s1 = Segment1(-120, 50)     # создали объект класса Segment1, на него ссылается переменная s1 - первый отрезок
    s2 = Segment1(100, 230)     # создали объект класса Segment1, на него ссылается переменная s2 - второй отрезок
    
    print(s1)   # [-120, 50]:170
    print(s2)   # [100, 230]:130

    # str(s1) возвращает строку. Эту строку сравниваем с образцом.
    assert str(s1) == '[-120, 50]:170'
    assert str(s2) == '[100, 230]:130'

# вызовем функции проверки
test_create()
test_length()
test_str()
```
Напечатает:
```python
-150 50
100 230
-120 -30
-100 20 120
[-120, 50]:170
[100, 230]:130
```
Главное, что нет AssertionError.

