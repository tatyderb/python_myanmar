# Тесты для классов

lesson = 

## class Point

Мы уже писали [class Point](https://stepik.org/lesson/532648/step/6?unit=525634)

Класс описывает точку на плоскости ХУ. 

* У точки есть координаты `x` и `y`.
* Точку можно:
    * создать
    * напечатать координаты
    
Класс Point определим в файле `point.py`
    
```python
class Point:
    """Точка на плоскости ХУ"""

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __repr__(self):
        return f'({self.x},{self.y})'

    def __str__(self):
        return f'{self.x} {self.y}'
```
В файле `test_point.py` определим тесты для этого класса.
```python
import unittest
from point import Point

class PointTestCase(unittest.TestCase):
    def test_create(self):
        p1 = Point(-5, 2)
        self.assertEqual(str(p1), '-5 2'))

        p2 = Point(6, -5)
        self.assertEqual(str(p2), '6 -5')

if __name__ == '__main__':
    unittest.main()
```
Запустим тесты из командной строки:
```python
 python .\test_point.py
```
Напечатает:
```python
.
----------------------------------------------------------------------
Ran 1 test in 0.011s

OK
```

Тесты можно запускать как обычную программу на python.

## Что еще можно сделать с точкой?

Добавим для точки следующие методы:

* **dist(other)** - расстояние от нашей точки до другой точки
* **move(dx, dy)** - подвинуть точку на dx и dy    
* **left()** - повернуть точку на +90 градусов относительно точки `(0,0)`. Еще можно написать поворот на -90 и 180 градусов. Это будет домашняя работа.
* **create(text)** - получает строку с координатами x и y, возвращает точку с этими координатами. Нужна будет в задачах

TODO IMG1 
нулевой рисунок:
расстояние между точками (3, 2) и (7, 5)
первый рисунок
1. исходная точка (2, -4)
2. ее сдвиг на (3, 7) -> (5, 3)
второй рисунок:
3. поворот налево на 90 градусов (5, 3) -> (-3, 5)

## Зачем нужны тесты

Напишем сначала тесты. Как мы будем использовать эти функции.

Зачем **сначала** писать тесты? Мы поймем:

* какие функции нужны **аргументы** (другая точка)
* что должна **вернуть** функция (расстояние до другой точки)
* **что делает** функция (вычисляет расстояние от нашей точки до другой точки)

Можно быстро написать код, сделать ошибку, потом долго ее искать.

Можно написать тесты, потом писать код. Сразу найдем ошибку. 

В маленькой программе будем долго писать тесты. Без тестов быстрее. В большой программе тесты сэкономят время на поиск ошибок и их исправление.

Научимся писать хорошие тесты.

## Тест функции dist

```python
d = p1.dist(p2)
```
Вычислить расстояние между p1 и p2.

Сначала надо написать очень простые тесты. Потом сложные.

* x=0, меняется y
* y=0, меняется x
* dx=3, dy=4, dist=5
* все координаты не 0
* длина - не целое число (посчитать на калькуляторе)

```python
    def test_dist(self):
        # x = 0, dist = dy
        p1 = Point(0, 5)
        p2 = Point(0, 2)
        d = p1.dist(p2)             # p1.dist(p2) - расстояние от p1 до p2
        self.assertEqual(d, 3)

        # y = 0, dist = dx
        p1 = Point(-5, 0)
        d = p1.dist(Point(2, 0))    # сделали Point(2, 0) и передали на него ссылку
        self.assertEqual(d, 7)

        # dx=3, dy=4, dist=5
        p1 = Point(4, 0)
        d = p1.dist(Point(0, 3))
        self.assertEqual(d, 5)

        # обязательно тест, где все координаты != 0
        p1 = Point(7, 5)
        d = p1.dist(Point(3, 2))
        self.assertEqual(d, 5)

        # не целая длина
        p1 = Point(7, 5)
        d = p1.dist(Point(-3, 2))
        # сравним 10.44030650891055 с точностью до 4 знаков
        self.assertAlmostEqual(d, 10.4403, places=4)
```

## Реализация метода dist

Реализуем метод `dist` в классе Point:
```python
    def dist(self, other):
        dx = self.x - other.x
        dy = self.y - other.y
        return math.sqrt(dx*dx + dy*dy)
```

Метод написать быстрее, чем тесты на него.

## Реализация других тестов и методов

Полная реализация:

* [point.py]() - class Point
* [test_point.py]() - тесты для класса Point

## Напишем один большой тест

Удобно: 1 тест проверяет 1 метод.

Можно: много тестов проверяют 1 метод, если метод сложный.

Не надо: 1 тест проверяет все методы. Если 2 метода с ошибкой, мы найдем один метод, и тест будет показывать неправильные данные.

Хорошо: один тест не зависит от другого. Это называется **атомарность** тестов.

На самом деле все тесты не работают, если ошибка в `__init__` или `__str__`. Поэтому создание и печать объектов пишут и проверяют в первую очередь.