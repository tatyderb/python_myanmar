# def

lesson = 1154755

## Функции, определенные пользователем

В этом уроке мы научимся создавать свои функции и пользоваться ими.

### Содержание

1. Зачем нужны функции
2. def
3. pass

### Для чего нужны функции

В программировании **функция - это часть кода с именем и быть может параметрами**.

То есть взяли несколько строк кода и сказали: теперь это будет называться функцией `foo`.

Для чего нужны функции? В программировании очень важна **читаемость кода**. Потому что в профессиональной разработке вы не будете писать 1001 маленькую программку, которые сразу же будут никому не нужны.

Вы долго будете писать много кода, который будет собираться в один программный продукт. Работать над ним будет несколько человек. Поэтому на 1 строку нового кода у вас будет много строк, которые надо прочитать и понять, что они делают, особенно, если в них ошибка.

Сейчас самый дорогой ресурс в программировании - это люди и время разработки. Мы будем стараться, чтобы другие люди могли быстро понять, что делает наш код и модифицировать его.

Как функции помогают повысить читаемость и сократить время разработки:

* **Повторное использование кода**, а не его copy-paste. Копипаста повышает шанс, что в каждом скопированном блоке будет своя ошибка. И время на исправления одной найденной ошибки во всех блоках выше, чем правки в одном месте.
* **Код разбит на блоки. У каждого блока есть понятное имя.** `read_students`, `sort_students_by_grade`, `print_exam_results`.
* **реализация скрыта**. Вы используете `print`, но не задумываетесь, как работает функция. Если у меня есть функция сложения векторов, то я легко перепишу её на новую математическую библиотеку, которая будет считать быстрее и лучше. Никому не придется править свой код по огромному проекту, я локализую изменения в тех функциях, которыми пользуются другие.

Это мы показывали в [курсе по питону на основе графики](https://stepik.org/course/92195) на `turtle` для школьников. Вы сможете убедиться, что функции - это здорово в [дополнительной главе](https://stepik.org/lesson/784099/step/1) к курсу, в которой мы напишем игру Space Invaders (Космическое вторжение). *Можете попробовать сразу пытаться написать игру, изучая тему за темой.*

Создадим свою первую функцию.

## user-defined function

Прежде чем замахиваться на суперполезные функции, которые будут сильно сокращать код, разберем создание (реализацию) и использование (вызовы) функции на простом примере.

Реализуем функцию `hi`, которая будет печатать `Hello!`

```python
# делаем функцию. 
# def - ключевое слово
# hi - придумали (сами) имя функции
def hi():
    print('Hello!')             # тело функции (все строки кода) пишем с отступами
    print('Здравствуйте!')

# закончились отступы - закончилась функция.
hi()   # вызов функции hi, функция печатает Hello! и Здравствуйте!
hi()   # вызов функции hi, функция печатает Hello! и Здравствуйте!
```
Напечатает
```python
Hello!
Здравствуйте!
Hello!
Здравствуйте!
```

* **Создание функции** (реализация) - один раз.
    * **Сигнатура функции** (заголовок) - первая строка функции, где определяем её имя и параметры
        * **def** - ключевое слово, от английского слова define (определим).
        * идентификатор - имя функции; правила создания идентификаторов вы знаете на примере переменных.
        * `()` - круглые скобки, в них потом будем писать аргументы; математики не мыслят функции без круглых скобок. Смиримся с этим.
        * `:` - двоеточие, 
    * после сигнатуры с **отступом в 4 пробела** напишем **тело функции** (код внутри функции)
* реализация функции **закончилась** там, где закончились отступы.
* **Вызов функции** (её использование, call) - много раз. Где хотим. Мы уже много раз использовали `print`. Наша новая функция ничуть не хуже. Мы её будем точно так же использовать.

**Сначала нужно реализовать функцию, потом ее использовать!** <br/>Сначала вяжем шарф, потом много раз его носим. Наоборот - нельзя.

### Как это работает?

```python
def hi():
    print('Hello!')         # тело функции пишем с отступами
    print('Здравствуйте!')

# закончились отступы - закончилась функция.
hi()   # вызов функции hi, функция печатает hello
print('The end')
```
1. Первые две строки. Программа начинает исполняться интерпретатором с самого начала. В начале создается объект - функция. Она не выполняется! Она только конструируется: определяется ее имя и что она делает (код внутри функции).
2. Далее идет **вызов** функции `hi()`. Управление передается в функцию и **исполняется код тела функции**, команда за командой. Печатается `Hello!` и `Здравствуйте!`
3. Когда функция заканчивает свою работу, управление передается на место **после** вызова функции, у нас это `print('The end')` и программа выполняется дальше.

То есть текущая позиция выполняемой команды (это и есть "управление передается") скачет сначала **внутрь функции**, а потом возвращается из нее и становится на место **после вызова функции**.

Если будет два вызова функции, например,
```python
hi()
hi()
```
то мы два раза прыгнем внутрь функции `hi()`, выполним её код, вернемся обратно и на следующем вызове `hi()` опять запрыгнем внутрь функции.

### pass

Можно ли написать еще более короткую функцию? Можно! Напишем функцию, которая *ничего не делает*. 

Тело такой функции состоит из ключевого слова **pass**.

```python
def do_nothing():
    pass
    
do_nothing()
do_nothing()
do_nothing()
do_nothing()
do_nothing()
# я тоже хочу ничего не делать, но приходится писать курс
```

*Зачем нужна такая функция? Не зачем, а когда! Мы пишем программу "сверху-вниз", то есть с верхнего уровня (прочитать данные, обработать их, напечатать результат) конкретизируя каждое действие (обработать данные - это разделить данные для каждого студента на имя и список баллов за каждую решенную задачу, что-то с ними сделать). Сначала на верхнем уровне мы пишем как будем использовать функции и их заголовки. Потом будем заменять pass на полезный код.*

```python
# моя большая программа по обработке результатов контрольной, версия 0.0.1
# в ней будут такие функции:

def read_task_score():
    pass
    
def process_task_score():
    pass
    
def print_student_list():
    pass
    
# их будут использовать так:
read_task_score()
process_task_score()
print_student_list()
```

## SKIP Соответствие

Реализация функции - один раз, создание функции.
Вызов функции - много раз, использование функции.
Заголовок функции - первая строка реализации функции
Тело функции - код внутри функции, пишем с отступом

## SKIP sort Собери программу

Расположите в правильном порядке строки кода, чтобы ваша программа напечатала `I love python` три раза.
```python
I love python
I love python
I love python
```

Код

```python
def love():
    print('I love python')
    
love()
love()
love()
```
   
## SKIP sort 

Расположите в правильном порядке

Заголовок состоит из

def
идентификатор - имя функции
()
:

## QUIZ

Что нужно написать вместо `???` в заголовке функции

```python
??? signature():
    print('С уважением, преподаватель кафедры КИВМ МФТИ.')
```

A. `def`
B. `define`
C. `definition`
D. тип возвращаемого значения
E. `set`

ANSWER: A

## TASKINLINE Флажки

Реализуйте функцию `flag`, которая печатает один флажок
```python
*
**
*

```
С ее помощью напечатайте узор из 4 флагов:
```python
*
**
*

*
**
*

*
**
*

*
**
*

```
CONFIG
score: 5
TEST
Входных данных нет
----
*
**
*

*
**
*

*
**
*

*
**
*

====

## TASKINLINE Флаг-2

**Внимание! Познакомимся с новым типом задач**, где нужно посылать 

* **ТОЛЬКО реализацию функции**.
* **имя функции должно совпадать с требуемым в задаче**.

В проверяющей системе **уже есть код**:
```python
flag()
flag()
flag()
```
*К посланному вами на проверку коду проверяющая система добавит свой код и выполнит все строки полученной программы.*

Реализуйте функцию `flag()` так, чтобы этот код печатал такую гирлянду флагов:
```python
**
**

**
**

**
**

```
**Посылать на проверку только реализацию функции flag()**. Остальной код с её вызовами уже есть в проверяющей системе.


CONFIG
score: 5
CODE
# только реализация функции, 
# ее вызовы уже есть в проверяющей системе.
FOOTER
flag()
flag()
flag()

TEST
Входных данных нет
----
**
**

**
**

**
**

====
