# Область видимости

lesson = 588212

## Область видимости переменной (name scope)

Разные люди могут иметь одинаковые имена. Разные переменные тоже могут иметь одно и то же имя.

**Область видимости** (name scope) - где видно и можно использовать переменную или функцию.

Внутри функции и ее аргументы - это **локальная** область видимости. При каждом **вызове функции** создается своя область видимости локальных переменных этой функции. 

```python
from math import sqrt  # функция вычисляет квадратный корень

def dist(x1, y1, x2, y2):
    dx = x1 - x2
    dy = y1 - y2
    res = sqrt(dx*dx + dy*dy)
    return res
    
def area(x1, y1, x2, y2, x3, y3):
    a = dist(x1, y1, x2, y2)
    b = dist(x1, y1, x3, y3)
    c = dist(x3, y3, x2, y2)
    p = (a + b + c) / 2
    res = sqrt(p*(p-a)*(p-b)*(p-c))
    return res

x1, y1, x2, y2, x3, y3 = map(float, input().split())
s = area(x1, y1, x2, y2, x3, y3)
print(s)
```

Сколько в этой программе переменных с именем `x1`?

* `x1, y1, x2, y2, x3, y3 = map(float, input().split())` - создали переменную `x1` 
* `def dist(x1, y1, x2, y2):` - при *каждом* вызове функции создается переменная `x1`, аргумент функции `dist`.
* `def area(x1, y1, x2, y2, x3, y3)` - при *каждом* вызове функции создается переменная `x1`, аргумент функции `area`.

Имя у переменных одинаковое `x1`. Переменные разные.

Аргументы **разных** функций могут иметь **одинаковые** имена. У функций `dist` и `area` есть аргумент с именем `x1`. Это разные переменные.

## Функция внутри функции

Если одна функция (dist) нужна только внутри другой функции (area), то можно **определить** dist внутри area.

Надо писать еще один отступ.

Вне `area` теперь `dist` не доступна. (Поэтому не пишите так. Это нужно только в очень больших программах.)

```python
from math import sqrt  # функция вычисляет квадратный корень
    
def area(x1, y1, x2, y2, x3, y3):
    # dist определена внутри area
    def dist(x1, y1, x2, y2):
        dx = x1 - x2
        dy = y1 - y2
        res = sqrt(dx*dx + dy*dy)
        return res
        
    # dist можно вызывать внутри area
    a = dist(x1, y1, x2, y2)
    b = dist(x1, y1, x3, y3)
    c = dist(x3, y3, x2, y2)
    p = (a + b + c) / 2
    res = sqrt(p*(p-a)*(p-b)*(p-c))
    return res

x1, y1, x2, y2, x3, y3 = map(float, input().split())
s = area(x1, y1, x2, y2, x3, y3)
print(s)
z = dist(x1, y1, x2, y2)    # ОШИБКА, тут функция dist не видна
```

Функция `dist` называется **внутренняя** для `area`. Функция `area` называется **объемлющая** (enclosed) для `dist`.

Во внутренней функции можно читать переменные объемлющей функции:
```python
def foo(a, b):
    k = 7
    def bzz(t):
        print(a + k + t)    # читаю a и k из внешней функции foo
        
    bzz(b*2)
    
foo(1, 3)  # вызовет bzz(2*3), она напечатает 14 = 1 + 7 + 2*3
```

## Глобальные переменные

Если переменная определена вне функций, то это **глобальная переменная**. Она видна внутри всех функций.

Напишем программу, которая считает и печатает, за сколько секунд упадет тело с высоты `h`, если начальная скорость 0.

$$ h = gt^2 $$
$$ t = \sqrt{\frac{h}{g}}$$

Здесь `g` - ускорение свободного падения.

```python
from math import sqrt

g = 9.81                # глобальная переменная g

def drop_time(h):       # локальная переменная (аргумент) h
    res = sqrt(h/g)     # используем глобальную переменную g
    return res

h = float(input())      # глобальная переменная h
t = drop_time(h)        # глобальная переменная t
print(f'Упадет на Земле за {t} секунд')
```

Нужно посчитать для Земли, Юпитера, Марса и Луны. На разных планетах разные `g`.

```python
from math import sqrt

g = 9.81                # глобальная переменная g

def drop_time(h):       # локальная переменная (аргумент) h
    res = sqrt(h/g)     # используем глобальную переменную g
    return res

h = float(input())      # глобальная переменная h

t = drop_time(h)        # глобальная переменная t
print(f'Упадет на Земле за {t} секунд')

g = 24.8                # Юпитер
t = drop_time(h)        # считаем с g Юпитера
print(f'Упадет на Юпитере за {t} секунд')

g = 3.72                # Марс
t = drop_time(h)        # считаем с g Марса
print(f'Упадет на Марсе за {t} секунд')

g = 1.62                # Луна
t = drop_time(h)        # считаем с g Луны
print(f'Упадет на Луне за {t} секунд')
```

## Создание переменной

Как работает `y = x + 5`

* Найти `x`
* Вычислить `x + 5`
* Если переменная `y` уже есть, присвоить ей значение `x + 5`.
* Если **переменной еще нет, то создать переменную** `y` и присвоить ей значение `x + 5`.

Как ищем `x` и `y`? **Правило LEGB**: ищем имя в 

* в локальной (local, L), 
* затем в локальной области любой объемлющей инструкции def (enclosing, E) или в выражении lambda, 
* затем в глобальной (global, G) 
* и, наконец, во встроенной (built-in, B). Встроенная область - это **функции питона** `print`, `input`, `abs` и другие.

![LEGB](https://stepik.org/media/attachments/lesson/588212/LEGB.png)

## Изменить глобальную переменную

```python
# Глобальная область видимости
X = 99          # X и func определены в модуле: глобальная область
def func(Y):    # Y и Z определены в функции: локальная область
    # Локальная область видимости
    Z = X + Y   # X – глобальная переменная
    return Z

func(1)         # func в модуле: вернет число 100
```
* Глобальные имена: X, func (так как объявлены на верхнем уровне модуля)
* Локальные имена: Y (аргументы передаются через присвоение), Z (создается через =)

**Присвоение создает переменную в текущей области видимости**
```python
x = 88          # глобальная переменная x

def func():
    x = 1       # СОЗДАЛИ локальную переменную x, переопределяет глобальную

func()
print(x)        # 88, печатаем глобальную переменную
```

## global

* читать глобальную переменную можно без global;
* global нужно, чтобы присваивать глобальным именам.

```python
X = 88          # Глобальная переменная X
def func():
    global X    # Х теперь будут искать в глобальной области видимости
    X = 99      # Глобальная переменная X: за пределами инструкции def
func()
print(X)        # Выведет 99
```

## NUMBER глобальная

Что напечатает?

```python
x = 1

def func():
    print(x)
    
func()
```

ANSWER: 1

## NUMBER переопределение

Что напечатает?

```python
x = 1

def func():
    x = 2
    
func()
print(x)
```

ANSWER: 1

## NUMBER global

Что напечатает?

```python
x = 1

def func():
    global x
    x = 2
    
func()
print(x)
```

ANSWER: 2
