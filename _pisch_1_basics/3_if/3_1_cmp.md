# Операторы сравнения

lesson = 1112154

## bool

В питоне кроме чисел и строк (типов `int`, `float`, `str` и так далее) есть тип данных, позволяющий отвечать на вопрос ДА или НЕТ. Этот тип называется `bool` (от английского слова boolean, по имени ученого [Джорджа Буля](https://ru.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D1%8C,_%D0%94%D0%B6%D0%BE%D1%80%D0%B4%D0%B6), основателя алгебры логики или [булевой алгебры](https://ru.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D0%B5%D0%B2%D0%B0_%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0)). 

ДА обозначается ключевым словом `True` (истина), НЕТ обозначается ключевым словом `False` (ложь).

Результат этого типа можно получить, например, при сравнении чисел. Выражение `2 < 5` имеет тип `bool` и значение `True`. Выражение `9 > -4` имеет значение `False`.

Это легко увидеть, вычислив значение выражения в интерпретаторе:
```python
>>> 2 < 5
True
>>> 9 < -4
False
>>> type(True)
<class 'bool'>
```
Или напечатав результат сравнения:
```python
print(2 < 5)    # True
```

Где используется этот тип, мы узнаем в следующем уроке. Сначала разберем операторы сравнения.

## Операторы сравнения

Математики пишут вместо слов "больше" и "меньше" специальные символы `>` и `<`.

На клавиатуре нет символа &ge;. Его программисты пишут как `>=` ("больше или равно" - знак "больше" стоит _перед_ знаком "равно", между этими знаками нельзя ставить пробел).

Как проверить, что $х$ равно 2, если `=` - это оператор "присвоить"? Написать `==`. Мы чаще присваиваем, чем проверяем равно или нет, поэтому "присвоить" - это один знак `=`, а "сравнить на равенство" - это 2 знака `==` подряд.

Знака &ne; тоже нет на клавиатуре. Его пишем как `!=` ("отрицание равно").

| В математике | В python | По-русски |
|---|---|-----|
| &gt; | `>` | больше |
| &ge; | `>=` | больше или равно |
| &lt; | `<` | меньше |
| &le; | `<=` | меньше или равно |
| = | `==` | равно |
| &ne; | `!=` | не равно |

**Можно писать сравнения, как математики, `2 <= x < 5`**

## SKIP Поставьте в соответствие

Поставьте в соответствие математической записи оператор в python.

±≠≤≥

## QUIZ

Как правильно записать математический знак &ge; (больше или равно) через операторы языка python?

A. &ge;
B. `>=`
C. `=>`
D. `ge`
E. такого оператора в python нет

ANSWER: B

## QUIZ

Как правильно записать математический знак &ne; (не равно) через операторы языка python?

A. &ne;
B. `!=`
C. `==`
D. `=!`
E. `!`
F. `not =`

ANSWER: B

## QUIZ 18+

Алкоголь в России не продают лицам моложе 18 лет. Какими условиями в коде можно проверить, что продавать алкоголь разрешено?

A. `age >= 18`
B. `age > 19`
C. `age > 17` 
D. `age < 17` 
E. `age < 19`
F. `age => 18`

ANSWER: A, C

## QUIZ Перерыв

В магазине перерыв с 12:00 до 13:00. В 12:00 магазин уже закрыт. В 13:00 магазин открыт. На часах hh:mm. Как написать проверку, что магазин закрыт на перерыв?

A. `12 <= hh < 13`
B. `12 <= hh <= 13`
C. `12 < hh <= 13`
D. `12 < hh < 13`
E. `12 < hh > 13`

ANSWER: A

## Равенство вещественных чисел

Вы [видели в задачах](https://stepik.org/lesson/1159165/step/7), что иногда при вычислениях вместо, например, 2.0 получается число 2.000000000000003 или 1.9999999999999991. 

Это происходит потому, что нецелые числа хранятся особым образом, не всегда точно. Если записывать число 1/3 в виде десятичной дроби, получится бесконечная десятичная дробь. Если хранить ее как 1.33333333333333, то у нас будет погрешность представления числа 1/3. При вычислениях погрешность будет накапливаться.

Десятичная дробь `0.1` в бинарном представлении будет *бесконечной бинарной дробью*. То есть будет храниться и входить в вычисления с некоторой погрешностью. Поэтому нецелые числа лучше сравнивать на равенство с некоторой точностью. Точность представления может зависеть от числа. Поэтому разумно считать, что два числа `a` и `b` равны с некоторой точностью `tolerance`. Будем считать эти числа равными с указанной точностью, если `a - tolerance < b < a + tolerance`или `abs(a - b) < tolerance`.

В курсе мы сделаем две поблажки ученикам.

1. Будем подбирать тестовые данные так, чтобы все необходимые проверки в коде на равенство можно было делать "в лоб", то есть писать `a == 0`, а не `abs(a) < tolerance`.

2. Как правило ответы в задачах с вещественными числами мы будем сравнивать с некоторой точностью. Обычно `0.0001`. Или писать в условии "напечатать с `n` знаками после точки", если будем сравнивать как обычно, посимвольно.

Заботу о погрешностях в вычислениях мы оставим тем студентам, которые будут специализироваться в вычислительной математике. Остальные могут просто принять во внимание, что погрешности вычислений существуют.

### Рецепт функции сравнения двух чисел с указанной точностью

```python
def eq_float(a, b, tolerance=0.0001):
    return abs(a - b) < tolerance
```  
