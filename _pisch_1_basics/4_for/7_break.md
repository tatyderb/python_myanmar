# break, continue, else

lesson = 1160432

## break, continue, else

Для цикла:

* `break` - [выходим из цикла](https://stepik.org/lesson/1120987/step/1), управление передается на первый оператор после цикла (или конец файла)
* `continue` - переходим к следующей итерации цикла:
    * `while` - на проверку условия продолжения цикла
    * `for` - к следующему элементу в последовательности (или выходим из цикла, если последовательность завершилась)
* `else` - есть у `for` и `while`, переходим сюда, если в цикле **не было** `break`.

Пример использования этих операторов:

```python
for x in range(100):
    if x == 2:
        print(x, 'Следующий!')
        continue
    if x == 5:
        print(x, 'Хватит!')
        break
    print(x, '...работаем')
else:
    print('без break')

print('конец')   
```
Напечатает:
```python
0 ...работаем
1 ...работаем
2 Следующий!
3 ...работаем
4 ...работаем
5 Хватит!
конец
```
Разберем подробно работу этих операторов на задаче [про яблоки в саду](https://stepik.org/lesson/1160430)

## Добавим ворон

На некоторых яблонях живут вороны. Они съели все яблоки с яблони. 1 ворона съедает 1 яблоко из корзины. 5 ворон съедают 5 яблок из корзины.

Так как они яблоки съедают, то будем обозначать числом `-5`, что на яблоне живет 5 ворон. 

Напишем код, который учитывает, что на яблоне могут жить вороны. Но перед этим напишем тесты (и таблицу изменения переменных для каждого теста).

### Тест 1

```cpp
5 -2 10 -6
```

| *i - номер яблони* | *x - количество яблок на 1 яблоне* | *res - уже собрали яблок* |
|---|---|---|
| 1 | 5 | 5 |
| 2 | -2 | 3 |
| 3 | 10 | 13 |
| 4 | -6 | **7** |

### Тест 2

```cpp
2 -5 10 -6
```

| *i - номер яблони* | *x - количество яблок на 1 яблоне* | *res - уже собрали яблок* |
|---|---|---|
| 1 | 2 | 2 |
| 2 | -5 | **0** |
| 3 | 10 | 10 |
| 4 | -6 | **4** |

Если в корзине 2 яблока, 5 ворон не могут оставить в корзине -3 яблока. Вороны не берут кредиты. Они едят настоящие яблоки. Поэтому после 5 ворон корзина будет пустая. Вороны вернулись на яблоню и больше отнимать яблоки не будут.

## TASKINLINE Вороны отнимают яблоки

1 ряд яблонь. На каждой яблоне могут быть или яблоки (число > 0) или вороны (число < 0).

Сколько всего яблок соберут с этих яблонь, если вороны отнимают яблоки?

Измените программу так, чтобы учитывались вороны.

```python
def row_sum(a):
    """ Считаем сколько яблок в ряду деревьев. """
    res = 0
    for x in a:
        res = res + x
        print(f'Собрали еще {x} яблок, всего собрали {res}')
    # после цикла возвратить сколько собрали яблок
    return res

a = list(map(int, input().split())) # прочитали 1 ряд деревьев в список
otvet = row_sum(a)                  # передали список a в функцию, функция вернула сумму   
print(otvet)                        # напечатали ответ
```

TEST
5 -2 10 -6
----
7
====
2 -5 10 -6
----
4
====
-1 -2 -3
----
0
====
1 2 3 6
----
12
====

## break - очень страшные вороны

![Рисунок break-06.svg](https://stepik.org/media/attachments/lesson/264320/break-06.svg)

Пусть мальчик очень боится ворон и, как только увидит на яблоне ворон, сразу убегает из ряда. Вороны не съели ни одного яблока. Дальше яблоки мальчик не собирает.

Входные данные:
```cpp
2 5 -3 6
```

| *i - номер яблони* | *x - количество яблок на 1 яблоне* | *res - уже собрали яблок* |  |
|---|---|---|---|
| 1 | 2 | 2 |  |
| 2 | 5 | 7 |  |
| 3 | -3 | **7** | Закончили обрабатывать ряд |
| 4 | ? | ? | Сюда не дошли |

Оператор **break** - управление передается за конец текущего цикла.

```python
def row_sum(a):
    """ Считаем сколько яблок в ряду деревьев. """
    res = 0
    for x in a:
        if x < 0:
            print(f'ВОРОНЫ {x}! break! run away!')  # уходим из for
            break
        res = res + x
        print(f'x = {x}, res = {res}')
        
    # сюда пришли после break
    
    # после цикла возвратить сколько собрали яблок
    return res

a = list(map(int, input().split())) # прочитали 1 ряд деревьев в список
otvet = row_sum(a)                  # передали список a в функцию, функция вернула сумму   
print(f'Собрали {otvet} яблок')     # напечатали ответ
```
Input:
```cpp
2 5 -3 6
```
Output:
```cpp
x = 2, res = 2
x = 5, res = 7
ВОРОНЫ -3! break! run away!
Собрали 7 яблок
```

## continue - продолжаем обрабатывать другие яблони

![Рисунок continue-07.svg](https://stepik.org/media/attachments/lesson/264320/continue-07.svg)

Если сборщик яблок храбрый, то он может обойти яблоню с воронами (не отдать им ни одного яблока!) и пойти собирать дальше.

Входные данные:
```cpp
2 5 -3 6
```

| *i - номер яблони* | *x - количество яблок на 1 яблоне* | *sum - уже собрали яблок* |  |
|---|---|---|---|
| 1 | 2 | 2 |  |
| 2 | 5 | 7 |  |
| 3 | -3 | **7** | пропускает эту яблоню |
| 4 | 6 | 13 | собрали яблоки за воронами |

Оператор **continue** - управление передается на следующую итерацию цикла. Мы идем к следующей яблоне.

```python
def row_sum(a):
    """ Считаем сколько яблок в ряду деревьев. """
    res = 0
    for x in a:
        if x < 0:
            print(f'ВОРОНЫ {x}')    #
            continue                # идем к следующей яблоне
        res = res + x
        print(f'x = {x}, res = {res}')
        
    # после цикла возвратить сколько собрали яблок
    return res

a = list(map(int, input().split())) 
otvet = row_sum(a)                  
print(f'Собрали {otvet} яблок')          
```
Input:
```cpp
2 5 -3 6
```
Output:
```cpp
x = 2, res = 2
x = 5, res = 7
ВОРОНЫ -3
x = 6, res = 13
Собрали 13 яблок
```

## return вместо break

Если после цикла ничего в функции нет, можно использовать `return` вместо `break`.

Тут функции нет, только break:
```python
a = list(map(int, input().split())) # прочитали 1 ряд деревьев в список

res = 0
for x in a:
    if x < 0:
        print('Вороны!')
        break
    res = res + x
    print(f'Собрали еще {x} яблок, всего собрали {res}')

# break перейдет сюда
print(res)  # ответ
```

Решение с функцией, заменим `break` на `return`. Тоже работает.
```python
def row_sum(a):
    """ Считаем сколько яблок в ряду деревьев. """
    res = 0
    for x in a:
        if x < 0:
            print('Вороны!')
            return res
        res = res + x
        print(f'Собрали еще {x} яблок, всего собрали {res}')
    # после цикла возвратить сколько собрали яблок
    return res

a = list(map(int, input().split())) # прочитали 1 ряд деревьев в список
otvet = row_sum(a)                  # передали список a в функцию, функция вернула сумму   
print(otvet)                        # напечатали ответ
```

## TASKINLINE Бонус храброму

Дано сколько яблок на каждой яблоне. В ряду могут быть вороны. Яблоки воронам не отдаем. Продолжаем собирать ряд дальше.

**В конце ряда стоит бонус. Еще 10 яблок, если в ряду не было ворон.**

```cpp
2 5 -3 6
```
Получим `2+5+6=13`. 
Бонуса нет, так как в ряду была ворона. 
Ответ: `13`

```cpp
2 5 3 6
```
Получим `2+5+3+6=16` 
В ряду не было ворон, значит **бонус +10 яблок** 
Ответ: `16+10 = 26`

TEST
2 5 3 6
----
26
=====
2 5 -3 6
----
13
====
1 5 -3 6 -10
----
12
====
-1 -2 -3 -4 -5
----
0
====

## for..else - если не было break

Убегаем от ворон. Дальше в ряду не собираем.

Но если дошли до конца ряда, то получаем бонус 10 яблок.

Мы знаем `for`.

Мы знаем `if` и `else`.

`else` - если в `for` не было `break` (и мы дошли до конца ряда!)

Тут функции нет, только break:
```python
a = list(map(int, input().split())) # прочитали 1 ряд деревьев в список

res = 0
for x in a:
    if x < 0:
        print('Вороны!')
        break
    res = res + x
else:
    # сюда пришли, если не было break в for
    res = res + 10

# break перейдет сюда
print(res)  # ответ
```

Решение с функцией, заменим `break` на `return`. Можно решить так:
```python
def row_sum(a):
    """ Считаем сколько яблок в ряду деревьев. """
    res = 0
    for x in a:
        if x < 0:
            print('Вороны!')
            return res
        res = res + x
    # после цикла - получили бонус
    res = res + 10
    return res

a = list(map(int, input().split())) # прочитали 1 ряд деревьев в список
otvet = row_sum(a)                  # передали список a в функцию, функция вернула сумму   
print(otvet)                        # напечатали ответ
```

## Вложенные циклы

Операторы `break` и `continue` во вложенном цикле работают только для него.

* `break` - выходим из цикла, управление передается на первый оператор после цикла (или конец файла)
* `continue` - переходим к следующей итерации цикла:
    * `while` - на проверку условия продолжения цикла
    * `for` - к следующему элементу в последовательности (или выходим из цикла, если последовательность завершилась)

Если нужно прервать внешний цикл или перейти к следующей итерации внешнего цикла, оформите код в виде функции.

### `break` по внешнему циклу

```python
def sum_garden(nrows):
    total = 0
    # это внешний цикл:
    for irow in range(nrows):
        seq = map(int, input().split())
        # это вложенный цикл:
        for x in seq:
            # break по внешнему циклу - используем return
            if x < 0:
                return total
            total += x
```

### `continue` по внешнему циклу

```python
def sum_row():
    total = 0
    seq = map(int, input().split())
    for x in seq:
        # continue по внешнему циклу - используем return
        if x < 0:
            return total
        total += x
    return total      
        
total = 0
for irow in range(nrows):
    total += sum_row()
    # все тело цикла должно быть в функции
```

### goto

В других языках программирования для `break` и `continue` по внешнему циклу используют оператор `goto`. В python его нет. Потому что это не "pythonic way" (не по-питонячьи!)

### else

Можно вернуть из функции не только `total`, но и еще одну переменную - встретились вороны или нет.

Разберем работу этих операторов на примере ворон в саду.

## TASKINLINE Сад с воронами

Дано `n` рядов яблонь.

В каждом ряду есть несколько яблонь. На них яблоки. Посчитать сколько всего яблок в саду. Если в ряду есть вороны, то убегаем от них и начинаем собирать следующий ряд.

Входные данные:
```cpp
3
15 24
7 -2 15
54 3
```
3 ряда.

* В первом ряду 15+24=39 яблок.
* Во втором ряду после -2 не собираем, то есть собрали 7 яблок
* В последнем ряду 54+3=57 яблок.

Всего в саду 39+7+57=103 яблока. Ответ: 103

TEST
3
15 24
7 -2 15
54 3
----
103
====
1
10 7 -2 11 104
----
17
====
10
1 1
2 -2
3 -3 3
4 -4 4 4
5 5 -5 5 5
6 6 -6 6 6 6
7 7 -7 7 7 7 7
8 8 8 -8 8 8 8 8
9 9 9 -9 9 9 9 9 9
10 10 10 -10 10 10 10
----
128
====

## Паника в саду

Напишем программу, которая после первой вороны убегает из всего сада.

```cpp
3
15 24
7 -2 15
54 3
```
* первый ряд 15+24=39
* второй ряд 7, дальше ворона -2 и больше яблоки не собираем.
* на следующий ряд не идем
 
 39+7 = 46

Функции в python может возвращать несколько переменных. Функция `row_sum` будет возвращать количество собранных в ряду яблок (как раньше) и были ли в ряду вороны.

* `res` - сколько яблок собрали в 1 ряду.
* `total` - сколько яблок собрали во всем саду.

```python
def row_sum(a):
    """ Считаем сколько яблок в 1 ряду."""
    res = 0
    for x in a:
        if x < 0:
            print('Вороны!')
            return res, True
        res = res + x
        print(f'Собрали еще {x} яблок, всего собрали {res}')
    # после цикла возвратить сколько собрали яблок
    return res, False

def all_sum(n):
    total = 0                               # сколько яблок собрали во всем саду
    for i in range(n):                      # ряд i от 0 до n-1
        a = list(map(int, input().split())) # прочитали 1 ряд деревьев в список
        res, vorony = row_sum(a)            # собрали яблоки в 1 ряду, вернули яблоки и были вороны?
        total = total + res
        if vorony:
            break                           # убегаем из сада (можно return)
            
    # сюда перейдет break
    return total                            # после цикла вернули все, что собрали
    
n = int(input())                    # сколько рядов в саду
otvet = all_sum(n)                  # передали количество рядов n в функцию, функция вернула сумму яблок в саду   
print(otvet)                        # напечатали ответ
```

## TASKINLINE Премия в конце работы

В саду растут яблони и живут вороны. Убегаем от вороны сразу из сада.

**Если в саду ворон не было, бонус в КОНЦЕ САДА, +50 яблок**

Пример 1:
```cpp
3
15 24
7 -2 15
54 3
```
* первый ряд 15+24=39
* второй ряд 7, дальше ворона -2 и больше яблоки не собираем.
* на следующий ряд не идем
 
 39+7 = 46

Пример 2:
```cpp
3
15 24
7 2 15
54 3
```
* первый ряд 15+24=39
* второй ряд 7+2+15=24
* последний ряд 54+3=57
* ворон не было, бонус +50 яблок.
 
 39+24+57<b>+50</b> = 170

TEST
3
15 24
7 2 15
54 3
----
170
====
3
15 24
7 -2 15
54 3
----
46
====
1
1 3 5 7
----
66
====
4
1 2 3
-4 5 6 
100 100
200
----
6
====
4
1 2 3
4 5 
6 7 8 9
-1 10
----
45
====
7
1
1
1
1
1
1
1
----
57
====