# Модули и пакеты

*Очень грубо говоря:*

* **Модуль** (module) - файл 
* **Пакет** (package) - директория

## Зачем?

* Разбиваем код на функции, классы, файлы, директории. 
* Организуем структуру проекта.
* Совместная работа (каждый работает над своей частью, пересекается с другими модулями по API)

## import

### Импорт модуля

```python
import math
y = math.sqrt(10) + math.sin(2)
```

* видно откуда берем `sqrt` и `sin` (из `math`, а не `numpy`)
* при одинаковых именах в разных модулях нет проблем, `math.sin` и `numpy.sin` - разные функции
* не можем повредить существующее пространство имен (если у нас в этом файле была определена функция `sin`)

### Импорт конкретных объектов из модуля

```python
from math import sqrt, sin
y = sqrt(10) + sin(2)
```
* видно, чем именно занимается ваш файл (`from json import dumps` - печатает)

### Импорт всех объектов из модуля (не одобряется)

```python
from math import *
y = sqrt(10) + sin(2)
```

* Так можно писать, только если у вас импортируется единственный пакет.

### Псеводонимы

```python
import matplotlib.pyplot as plt
plt.plot([1, 2, 3], [1, 4, 9])
```

## Разница импорта и непосредственного запуска файла, `__name__`

```python
print(f'run a.py, __name__={__name__}')

if __name__ == '__main__':
    print('Меня запустили!')
else:
    print('Меня импортировали...')
```

Запустим файл `a.py` тем или иным способом:

* `python a.py` - запуск скрипта
* `python -m a` - запуск как модуля, `-m` и не пишем `.py`

Напечатает
```commandline
run a.py, __name__=__main__
Меня запустили!
```

* В файле `b.py` напишем `import a` и запустим `b.py`
* Запустим интерпретатор и в нем сделаем `import a`

```commandline
run a.py, __name__=a
Меня импортировали...
```

**Обратите внимание, весь код в импортируемом файле выполнился в момент импорта!**

При импортировании файла получаем "мусор" в печати. Чтобы его не было, код, который НЕ НАДО выполнять при импорте,
пишут как

```python
if __name__ == '__main__':
    # меня запустили
    # код, который не надо выполнять при импорте, например, тесты
```

## Файл лежит в директории

Файл `a.py` лежит в директории `demo_import`. Поднимемся из этой директории на уровень выше и запустим скрипт с указанием директории и файла, пакета и модуля.

Раньше, чтобы директория стала настоящим пакетом, обязательно в ней должен был быть файл `__init__.py`, быть может пустой.
Сейчас можно обойтись без этого файла.

Указывая путь к модулю, пишем через `.`
```commandline
C:\Users\taty\PycharmProjects\demo_import>cd ..

C:\Users\taty\PycharmProjects>python demo_import\a.py
run a.py, __name__=__main__
Меня запустили!

C:\Users\taty\PycharmProjects>python -m demo_import.a
run a.py, __name__=__main__
Меня запустили!
```

## import и from - выполняемые инструкции (присвоения)

* можно вложить в `if`, `def`, `try` и тп
* работают только тогда, когда до них дойдет интерпретатор

```python
def run_game(mode):
    if mode == 'gui':
        # импортируем только если нужно запустить игру с графикой
        import pygame
        run_gui_game()
    else:
        # при запуске текстового варианта игры не требует установленного пакета pygame
        run_text_game()
```

## Объекты шарятся

```python
# a.py
x = 1
y = [1, 2]
```
импортируем в другой файл
```python
# c.py
from a import x, y
# x и y ссылаются на те же объекты

x = 15          # создали переменную с именем x
y[0] = 777      # изменили объект, на который указывал y

import a

print(f'{x=} {y=} {a.x=}')  # x=15 y=[777, 3]  a.x=1
```
![картинка](https://github.com/tatyderb/python_express_course/raw/master/assets/modules_namespace.png)

Хотим изменить `x` в другом файле.

* Не надо так! Вы не найдете потом кто, где и когда поменял ваши переменные (поиск ошибки).
* Нельзя поставить отладочную печать в одно место и посмотреть когда и кто поменял `x`
* Напишите функцию-обертку в том же файле, которая меняет `x`

```python
# a.py
x = 1
def set_x(val):
    x = val
```

## Где ищутся пакеты и модули?

* переменная окружения `PYTHONPATH`
  * форма записи зависит от ОС
* `sys.path` (она же, то есть можно менять содержимое "на лету")
* В зависимости от запуска скрипта/модуля
  * при запуске скрипта добавляется директория этого скрипта
    * `python demo_import\a.py` добавит в путь `demo_import`
    * `python a.py` добавит в путь текущую директорию
  * запуск с ключом `-m` добавляет в путь `''`
* IDE при запуске из нее может менять, исходя из выставленных настроек IDE (обязательно проверяете работу программы вне IDE)

### Как посмотреть где ищутся модули?

`sys.path`

## Атрибуты и функции

* `__name__` - имя модуля, стартовый модуль имеет имя `__main__`
  * `dir(a)` - для модуля `a` перечислить все его атрибуты (список атрибутов)
* `a.__dict__` - для модуля `a` все, что есть в пространстве имен (словарь атрибут и значение)

## Что может быть модулем

Почему при `-m` или `import` мы не пишем `.py` в имени модуля? Что может быть модулем?

* файл с исходным кодом b.py
* байт-код этого файла b.pyc
* содержимое каталога b при импортировании пакета (см. далее "Пакеты модулей")
* Скомпилированный модуль расширения, написанный, как правило, на языке C или C++ и скомпонованный в виде динамической библиотеки (например, b.so в Linux и b.dll или b.pyd в Cygwin и в Windows).
* Скомпилированный встроенный модуль, написанный на языке C и статически скомпонованный с интерпретатором Python.
* Файл ZIP-архива с компонентом, который автоматически извлекается при импорте.
* Образ памяти для фиксированных двоичных исполняемых файлов.
* Класс Java в версии Jython.
* Компонент .NET в версии IronPython.

## `.pyc` компиляция байт-кода

Если .pyc файла нет, его создают;

* Интерпретатор проверяет время модификации файла .py и .pyc (кода и байт-кода). 
* Если байт-код устарел (время модификации файла .py больше, чем время модификации файла .pyc), то перекомпилируют .py файл.
* Далее используется .pyc файл.

Пожалуйста, не кладите `.pyc` файлы в репозитории.

## Выполнение кода

* Все инструкции байт-кода выполняются по порядку, сверху вниз.
* Все операции присвоения (`=`, `def`, `class`, `import`) создают новые атрибуты объекта модуля. 

Заметьте, если в файле на верхнем уровне (вне всяких функций) был вызван `print`, то он выполнится в этот момент.

# Аннотации типов

[
Типизированный Python для профессиональной разработки](https://to.digital/typed-python/intro/intro.html)

* Читаемость кода, скорость разработки
* Для IDE, не проверяет при выполнении
* В функциях и переменных
* Простые типы
* int | float
* from typing import TypeAlias
  * `Celsius: TypeAlias = int`
* Сложные типы (старый синтаксис List, Dict)
  * list, 
  * list[int],
  * Iterable[User] - перебрать в for, Sequence - есть индекс, Mapping - доступ по ключу
  * dict, 
  * dict[str, int],
  * dict[Literal["longitude"] | Literal["latitude"], float]
  * tuple[int, int, int] - кортеж из 3 чисел
  * tuple[int, ...] - кортеж из неизвестно скольки чисел

```python
from typing import Callable

def mysum(a: int, b: int) -> int:
    return a + b


def process_operation(operation: Callable[[int, int], int],
                      a: int, b: int) -> int:
    return operation(a, b)

print(process_operation(mysum, 1, 5))  # 6
```

* from typing import Any
  list[Any]
* < 3.11 Self в typing_extention

```python
from typing import Any
from typing import Self    # < 3.11 from typing_extention import Self

class Stack:
    def __init__(self) -> None:
        self.items: list[Any] = []

    def push(self, item: Any) -> Self:
        self.items.append(item)
        return self

    def pop(self) -> Any:
        if self.__bool__():
            return self.items.pop()
        else:
            raise ValueError("Stack is empty")

    def __bool__(self) -> bool:
        return len(self.items) > 0
```

* Использовать недоопределенные типы или определенные позже
`from __future__ import annotations`


```python
from __future__ import annotations

from typing import Any

class Stack:
    def __init__(self) -> None:
        self.items: list[Any] = []

    def push(self, item: Any) -> Stack:  # могу использовать Stack
        self.items.append(item)
        return self

```